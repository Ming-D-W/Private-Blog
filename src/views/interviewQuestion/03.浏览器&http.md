---
title: 浏览器&http
date: 2022-02-31 15:02:16
permalink: /pages/d178b0/
categories:
  - 更多
  - 技术面
tags:
  - 面试总结
---


## 强缓存&协商缓存

> 浏览器发起HTTP请求 – 服务器响应该请求。那么**浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，需要缓存的话就将请求结果和缓存标识存入浏览器缓存中**
>
> 缓存机制的基本原则是：
>
> - 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
> - 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
>
> **强制缓存就是向浏览器缓存查找该请求结果，并根据这个结果的缓存规则来决定是否使用该缓存结果的过程。**
>
> 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，**控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。**
>
> **Expires** 是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。
>
> > Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？
>
> 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？
>
> ##### Cache-Control
>
> 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：
>
> - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
> - private：所有内容只有客户端可以缓存，Cache-Control的默认取值
> - no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
> - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
> - max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
>
> 由于Cache-Control的优先级比expires高，在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

浏览器的缓存主要是为了提高访问效率，什么是**强制缓存** 呢？比如说我们访问一个网站，当我们第一次访问的时候，里面一些静态资源，比如说图片啊CSS，JS这些资源，甚至icon。这些实际上是从服务器上下载的。但是如果说我们刷新网页的话，那这个资源是没有必要在服务器上重新去请求的，因为他没有变动。那像这种资源的话，浏览器会默认是一些强制缓存。那么强制缓存，当你第二次访问的时候，他不会再去服务器上重新下载，同样他会给你返回一个200的状态码，但是这个资源呢，它会从浏览器的本地缓存里去取这种图片，像这种图片第二次去取的缓存的状态，就是一种强制缓存。

**协商缓存** ，就是我们和后台去协商这个资源，要不要对它去进行缓存。如果这个资源是需要协商缓存的，那第一次返回的结果里面的状态码是200，同时会携带一个是否更新Last Modified的一个状态，还会给他返回一个唯一标识etag，可以理解为是一个内容资源的hash。只要说这个资源在服务端没有变化，那么当下次访问的时候，后台会对比这个标签etag，或者说对比这个Last Modified的时间。如果这个资源没有变动，那么他会告诉你返回一个304的状态码，那当浏览器接收到这个304的状态之后，他会认为这个资源没有变化，我只需要从本地把这个缓存的资源拿出来就行了

## cookie

## TCP UDP



## 在浏览器里输入url会经历哪些流程？

输入url会发生什么事情？

1. 核心：引到自己擅长的领域

2. 域名 ==> 解析成IP【DNS服务器做的这个事情】

3. TCP的三次握手，四次挥手

4. 连接建立

5. 服务器端会根据当前这次请求的请求头里面的if-modifined-since，和服务器端的当前文件的上次修改时间进行对比，如果一致，本地缓存可用，服务器返回304的状态码，直接使用本地的缓存资源

6. 强缓存

   1. 第一次请求服务器端资源的时候，服务器不仅返回当前资源，同时会通过响应头里面cache-control:max-age=最大缓存时间

   2. 下次请求的时候，先判断缓存是否到期，如果没有到期，使用本地缓存资源，如果到期，请求服务器端

7. 如何合理的设置强缓存

   1. html不能加缓存

   2. js和css需要添加强缓存，但是每个文件需要一个唯一的hash值，如果没有hash值的话，强缓存会一直命中，导致的问题是：加入服务器端文件更新了，本地浏览器端获取不到最新的内容

1. 浏览器获取到html页面的时候，先解析一下html，预加载的文件，会提前加载，预解析完毕以后，开始绘制界面，构建HTML树，构建css树，合并成渲染树，调用显卡渲染到页面上。
2. js的异步加载

### 问1： 为什么把CSS加载放在head里？

如果我们把css加载放在最后，这时候页面已经渲染完成了，然后发现css改变了，还有重新一个个去查找渲染一遍，这样就拖慢了页面渲染的速度

### 问2：为什么要把js加载放着body最后？

因为遇到`<script>`会暂停渲染，如果把js加载放在前面，这时页面还没渲染完，暂停住了，就加长了整个页面渲染的时间。

## 性能优化

### 1. 浏览器加载资源优化

- 减少资源体积：压缩代码

- webpack打包会压缩代码

- 减少访问次数：合并代码，ssr（服务端渲染），缓存

- 合并代码

```js
//三次网络请求
<script src="a. js"></script> 
<script src="b. is"></script> 
<script src="c. js"></script>

//合并成一次网络请求,网络请求减少了 
<script src="abc.js"></script>
```

- 缓存(强缓存&协商缓存)
- SSR：服务端渲染
- SSR(前后端不分离）：将网页和数据一起加载
- 非SSR（前后端分离）：先加载网页，再加载数据，再渲染数据

### 2. 浏览器渲染优化

- CSS放着head，JS放在body最下面

- 尽早开始执行JS，页面渲染完之后马上开始执行js，不要在图片资源加载完后才去执行JS

- **图片懒加载**

  用户看到第一屏的图片先加载，在屏幕之外的图片先加载一张本地预览图片，等用户滑动到的时候再加载，如果用户快速滑动，会先显示一张预览图片的占个位，等到网络请求完成了，预览图就变成了真正的网络请求下来的图片。

- 对DOM查询操作进行缓存

- **减少回流重绘**

  - 多个属性尽量使用简写，例如：boder可以代替boder-width、boder-color、boder-style
  - 避免频繁修改样式，可以使用CSS class来批量修改样式。
  - 先把这个元素隐藏，然后把样式该加的全部加上，然后最后再显示，只会有一次回流和重绘
  - 将多次修改DOM的操作合并为一次，减少重绘和回流的次数。

- 节流**throttle**

  拖拽一个元素时，要随时拿到该元素的被拖拽的位置，直接使用原生事件会频繁触发，很容易造成卡顿。无论拖拽多快，我们可以每隔500ms触发一次

- 防抖**debounce**

  例如，我们在输入框中快速的输入文字的时候，不能实时进行网络请求，可以每次输入后的500ms后进行一次网络请求，这样可以大大减少网络请求的次数。

### 3. 打包层面
1. **移除console.log**: 通过babel的插件进行移除(babel-plugin-transform-remove-console)

2. soucemap:  映射生产阶段的代码和开发阶段的代码的对应关系,在生产阶段报错,根据map的映射文件提示出开发阶段的代码哪里出错, 项目真正上线,关闭(线上出现bug)

3. **路由懒加载**: 当路由匹配的时候才会加载响应资源

4. splitChunks: 提取公共资源, 某一个文件被多次引入, 进行公共提取

5. gzip压缩:  compression-webpack-plugin, 需要后端开启支持

6. **图片压缩**: image-webpack-loader  实现图片压缩

7. runtimeChunks: 开启运行时代码, 运行时代码发生变化不影响app主模块的hash变化(可以继续使用强缓存)

8. 使用更快的网络：**CDN**，配置config，

   之后通过 `html-webpack-plugin`注入到 `index.html`之中:

   ```javascript
   config.plugin('html').tap(args => {
     args[0].cdn = cdn
     return args
   })
   ```

   在index.html注入cdn配置

9. ssr: 服务端渲染
   解决首屏加载速度慢的问题,首屏服务端直接返回,还可以解决seo,实现ssrvue结合nuxt

#### 服务端渲染ssr

- 为什么?
  spa单页面应用的seo不友好,spa单页面,由js进行渲染页面,不同的路由规则渲染不同的组件,对应html就是一个空页面,百度爬虫在爬,什么都爬不到,导致seo不友好

- ssr
  服务端渲染: 先由服务端将页面解析好返回,返回之后,浏览器进行渲染,直接将页面的内容进行渲染,html不在是一个空页面,爬虫可以爬到

- 配置
  路由: 在pages下创建文件,自动生成路由

  ui组件库: 在nuxt.config.js中通过plugins节点指定配置文件的路径,在对应的路径文件中进行配置

  css全局样式: 可以在nuxt.config.js中的css节点中进行配置

  seo优化: nuxt.config.js中通过head进行title和meta的配置

  在pages中也可以通过head进行页面级别的配置

- 获取数据

  生命周期分为

  **服务端**

  nuxtServerInit: 服务端初始化

  RouteMiddleware: 中间件

  validate: ok

  asyncData: 获取服务端数据

  asyncData中进行获取数据,该生命周期是在服务端执行的,所以不能使用this

  - 服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取
    - 首屏异步获取数据，在服务端预渲染的时候就应该已经完成
    - 切换组件通过`mixin`混入，在`beforeMount`钩子完成数据获取

  **客户端**
  created => fetch(fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。) = mounted

## 图片懒加载

**IntersectionObserver**

网页开发时，常常需要了解某个元素是否进入了"视口"（viewport），即用户能不能看到它。

传统的实现方法是，监听到 scroll 事件后，调用目标元素的 getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。

目前有一个新的 IntersectionObserver API，可以自动"观察"元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做"交叉观察器"。

**API**
IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。

```javascript
var io = new IntersectionObserver(callback, option)

// 开始观察
io.observe(document.getElementById('example'))

// 停止观察
io.unobserve(element)

// 关闭观察器
io.disconnect()
```

如果要观察多个节点，就要多次调用这个方法。

```javascript
io.observe(elementA)
io.observe(elementB)
```

目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。

```javascript
var io = new IntersectionObserver((entries) => {
  console.log(entries)
})
```

callback 函数的参数（entries）是一个数组，每个成员都是一个 IntersectionObserverEntry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。

- time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒
- target：被观察的目标元素，是一个 DOM 节点对象
- isIntersecting: 目标是否可见
- rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null
- boundingClientRect：目标元素的矩形区域的信息
- intersectionRect：目标元素与视口（或根元素）的交叉区域的信息
- intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1，完全不可见时小于等于 0

## 跨域

跨域是由于浏览器的同源策略，协议、域名、端口号其中任一不同即为跨域，但是服务器和服务器之间不存在跨域。

历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：

- JSONP
- CORS
- 服务器代理(webpack代理, Nginx反向代理)

**JSONP**

这是一种非常经典的跨域方案，它利用了`<script>` 标签不受同源策略的限制的特性，实现跨域效果。

优点：

- 实现简单
- 兼容性好

缺点：

- 只支持 GET 请求 （因为 `<script>` 标签只能发送 GET 请求）
- 存在被 XSS 攻击的可能，缺乏安全性保证
- 需要服务端配合改造

**CORS**

跨域资源共享（CORS），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 HTTP 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。

当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 HTTP 请求。

### 开发环境下解决跨域问题

**webpack反向代理**

开发环境下我们启动了本地的localhost服务器，使得浏览器和本地服务器是同源，不存在跨域。

那么我们就让本地服务器转发请求给远程服务器，远程服务器返回数据给本地服务器，本地服务器再转返回给浏览器。

这就是**webpack反向代理**。

![webpack反向代理](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303280925640.png)

### 生产环境下解决跨域问题

**nginx反向代理**

反向代理的原理其实很简单：

> Nginx 作为代理服务器，所有客户端的请求都必须先经过 Nginx 的处理，然后再将请求转发给其他后端程序（比如 Node.js 或Java 程序），这样就规避同源策略的影响

```nginx
    # 请求转发：
    # 例如 http://localhost/api 的请求会被转发到 http://124.222.141.165:99   
		location /api {
        proxy_pass http://124.222.141.165:99/;
    }
```



## http版本

HTTP1.0：

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

服务器完成请求处理后立即断开TCP连接。

简单来讲，每次与服务器交互，都需要新开一个连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，在同一个TCP连接里面，客户端可以同时发送多个请求

- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着

- 新增了一些请求方法，新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式

- 多路复用，只需一个连接即可实现并行

- 使用报头压缩，降低开销

- 服务器推送

HTTP3.0：

- 是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。

## http&https

> 总结：
>
> 1. http明文传输
>
> 2. https加密传输
>
> 3. http默认的端口号80
>
> 4. https默认的端口号是443
>
> 5. 加密算法：对称加密，非对称加密，hash算法
>
> 6. https的传输过程使用对称加密，传输之前先用秘钥进行加密，加密传输，目标端使用相同的密钥解密。

1. HTTPS 是安全版的 HTTP。

2. HTTP 协议在传输数据时采用的是**明文传输**，因此，⼀些敏感信息的传输就变得很不安全。

3. 而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的

4. HTTPS 在传输数据的过程中会对数据进行**加密处理**，保证安全性。

5. CA证书确保公钥的安全性，防止代理服务器伪造，或者网站不安全

6. 数字签名用于保证CA证书没有被篡改过，是源服务器签发的证书

> ssl证书：SSL 证书就是遵守 SSL协议（它是在传输通信协议（TCP/IP）上实现的一种安全协议，采用公开密钥技术），由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能

> http：基于7层协议中的应用层（提供应用程序间的交换和数据交换）
> https：基于7层协议中的传输层（传输层协议提供计算机之间的通信会话，并确保数据在计算机之间可靠地传输。）
> 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

 **对称加密**

发送方和接收方使用同一个密钥（一串字符串）进行加密和解密

1. 服务端使用密钥进行加密

2. 客户端使用密钥进行解密

   但是第一次要传输一次密钥，如果密钥被拦截，就被破解了

   性能好，速度快，缺点，密钥被拦截被破解

 **非对称加密**

公钥加密，私钥解密

1. 服务端

2. 客户端

3. 客户端公钥加密传输（被拦截无法解密，需要用私钥）

4. 服务端通过私钥解密

   优点：安全

   缺点：性能差，耗时间

> 使用非对称加密进行密钥传输，使用对称加密进行数据传输
> 如何保证首次传输的公钥是安全的，需要网站机构，进行网站和公钥的登记（CA机构，颁发证书，安全可靠）


## 状态码

**1xx: 请求处理成功状态码**

代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

> 100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
>
> 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级

**2xx: 请求处理成功状态码**

代表请求已成功被服务器接收、理解、并接受

> 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
>
> 201（已创建）：请求成功并且服务器创建了新的资源
>
> 202（已创建）：服务器已经接收请求，但尚未处理
>
> 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
>
> 204（无内容）：服务器成功处理请求，但没有返回任何内容
>
> 205（重置内容）：服务器成功处理请求，但没有返回任何内容
>
> 206（部分内容）：服务器成功处理了部分请求

**3xx：请求重定向**

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

> 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
>
> 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
>
> 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
>
> 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
>
> 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
>
> 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

**4xx: 请求失败**

代表了客户端看起来可能发生了错误，妨碍了服务器的处理

> 400（错误请求）： 服务器不理解请求的语法
>
> 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
>
> 403（禁止）： 服务器拒绝请求
>
> 404（未找到）： 服务器找不到请求的网页
>
> 405（方法禁用）： 禁用请求中指定的方法
>
> 406（不接受）： 无法使用请求的内容特性响应请求的网页
>
> 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
>
> 408（请求超时）： 服务器等候请求时发生超时

**5xx：服务器问题**

表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

> 500（服务器内部错误）：服务器遇到错误，无法完成请求
>
> 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
>
> 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
>
> 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
>
> 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
>
> 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## get和post请求的区别
