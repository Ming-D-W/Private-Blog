---
title: JS
date: 2022-02-31 14:59:21
permalink: /pages/e4dc2c/
categories:
  - 更多
  - 技术面
tags:
  - Javascript
  - 面试总结
---



## 回调函数的概念

> **fs模块** 
>
> fs.writeFile('文件路径'，'编码格式'，function(err,dataStr){})
>
> - fs.writeFile是读取文件的方法，第一个参数是文件路径，可以写绝对路径也可以写相对路径。**__dirname**为当前目录可以用来拼接文件路径
> - 第二个参数是编码格式，一边采用utf-8 国际码
> - 第三个参数是回调函数，err成功时为null，失败时为失败信息。可以用err!==null来判断是否执行成功。dataStr为读取的文件内容。

JavaScript 语言对异步编程的实现，就是回调函数。**所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。** 它的英语名字 `callback`，直译过来就是"重新调用"。

读取文件进行处理，是这样写的。

```javascript
 fs.readFile('/etc/passwd', function (err, data) {
   if (err) throw err;
   console.log(data);
 });
```

上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。

一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。

## 数组的常用方法有哪些?

- join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符
- push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)
- pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）
- shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined
- unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）
- slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变
- splice(start,deleteCount,val1,val2,…):从start位置开始删除deleteCount项，并从该位置起插入。（修改原数组）
- fill()：使用特定值填充数组中的一个或多个元素(修改原数组)
- filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组
- concat()：可以将两个数组合并在一起，如果是使用ES6语法也可以用扩展运算符…来代替
- indexOf()：返回当前值在数组中第一次出现位置的索引
- lastIndexOf()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。
- every()：判断数组中每一项是否都符合条件
- some()：判断数组中是否存在满足的项
- includes()：判断一个数组是否包含指定的值
- sort(orderfunction):按指定的参数对数组进行排序(修改原数组)
- reverse()：将数组反序(修改原数组)
- forEach()：循环遍历数组每一项（没有返回值）
- map()：循环遍历数组的每一项（有返回值）
- copyWithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）
- find(): 返回第一个匹配的值，并停止查找
- findIndex(): 返回第一个匹配值的索引，并停止查找
- toLocaleString()、toString():将数组转换为字符串
- flat()、flatMap()：扁平化数组
- entries() 、keys() 、values():遍历数组

## new关键字的执行过程

将新对象的__proto__ 指向了构造函数的原型对象（prototype）
将构造函数内部的this指向新对象
执行构造函数给this(实例对象)添加属性或方法
默认return this
如果写了return 看 数据类型
数据类型是简单数据类型: return简单数据类型忽略 最终还是return this
如果数据类型是复杂数据类型: 最终得到是该复杂数据类型 return this无效

## ES6

- let const

- 箭头函数
- 解构赋值
- 模板字符串
- class
- Promise
- Set&Map

### let const

1. var声明的变量作用域是函数级别的，而 let 和const 声明的变量作用域是块别的，块级别作用域可以是一个函数、一对花括号或一个模块。

2. 使用var声明的变量可以在声明之前访问，但是其值为undefined，而let 和const声明的变量在声明之前访问会抛出 ReferenceError。

3. var 声明的变量可以被重复声明，而let和const声明的变量不允许重复声明。

4. 使用let声明的变量可以被重新赋值，而使用const声明的变量是不可变的，即其值不能被重新赋值

5. const声明的变量必须在声明时初始化，不能在之后赋值。

### Set&Map

### 箭头函数和普通函数的区别

1. 箭头函数this指向上下文，普通函数this看调用方式

2. 剪头函数没有arguments对象，普通函数具备arguments对象

3. 箭头函数没有prototype, 普通函数具备prototype

4. 箭头函数不能用做构造函数，普通函数可以用做构造函数

### Promise

**概念**

promise是一个对象/构造函数,es6新增的,更加灵活的处理异步,也可以解决回调地狱问题

promise有三种状态:pending fullfield rejected状态不可逆 pending => (resolve)fullfield，pending =>(rejecte) rejected

**实例方法 **

- then方法：接收promise处理后的结果，
  - 第一个回调接收成功的结果，第二个回调用于接收失败的结果
  - then支持链式调用，在then中可以返回新的promise，并且调用resolve，会将成功的结果传递到下一个then中，所以借助then的链式解决了回调地狱的问题
  - 具备穿透性：在then中通过返回的promise调用resolve传递数据，下一个then如果没有通过回调进行接收，则会继续向下传递
  - then的返回值是promise，而且then的成功回调如果返回的不是promise，也会被then的promise的resolve进行处理
  - 终止then的成功回调的链式：reject、throw Error Promise.reject

- catch方法：专门处理失败的状态

- finnaly方法：都会执行

 **静态方法**

- all：同时处理多个异步，语法参数为数组，数组每一项是Promise实例，只有所有异步处理成功，才会进入then的成功回调，有一个失败，进入all的then的失败回调，结果是数组，值对应的就是参数数组的顺序

- allsettled：语法基本和all一致，不管处理的异步中是否调用reject，最终都会进入allsettled的成功回调，在成功的回调中，数组每一项是对象，对象会有status，状态，成功或失败，还有value就是异步处理的结果

- race：语法基本和all一致，可以获取到异步处理最快的那一个，在then中通过成功回调或失败回调获取结果

- any：语法基本和all一致，可以获取到异步处理成功最快的那一个

**async和await**

promise的终极解决方案是async await

await 用来修饰promise, 当然await也可以修饰非promise，如果修饰的不是promise则会将 await后面的内容包装为promise，await的返回值会一直是promise的resolve处理，await下面的代码相当于是promise的then成功回调的代码，所以await下面的代码属于异步微任务

async用来修饰await就近的函数，被async修饰的函数，该函数返回值为promise，内部如果return数据，则该数据被promise的resolve进行处理，所以需要通过函数的then的成功回调获取期结果

async和await实际是generator的语法糖

**Generator**

概念: 也是es6的,可以将函数的控制权交出,也可以利用generator更方便的控制异步,实际async和await就是他的语法糖

区分: 星号

如何交出控制权: 通过yield进行控制权交出,通过next逐步调用

如何处理异步: 可以通过yield配合promise达到类似async和await的效果,通过yiled返回promise,在promise中处理异步,等异步成功调用resolve,这样在外部可以通过next.value获取到promise,通过then等待成功后,执行下一次的next

而且对应的自执行generator函数有co库,可以去自执行generator

区别:

![img](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202305131525902.png)

## for in&for of

1. 遍历的对象不同：
   for...in循环用于遍历对象的可枚举属性。它会枚举对象及其原型链上的所有属性，包括继承的属性。它主要用于遍历对象属性。
   for...of循环用于遍历可迭代对象中的值，例如数组、字符串、Map、Set等。它不适用于普通对象。

2. 迭代顺序不同：
   for...in循环的迭代顺序是不确定的，因为它是按照对象属性的添加顺序进行迭代的，但是对象的属性顺序是不确定的。它不能保证属性的顺序。
   for...of循环的迭代顺序是由迭代器决定的，通常是按照元素在集合中出现的顺序进行迭代的。

3. 迭代的值不同：
   for...in循环迭代的是属性名，而不是属性值。因此，要访问属性值，需要使用对象的属性访问方法，例如obj[key]。
   for...of循环迭代的是值。例如，对于数组，它迭代的是数组元素的值。

4. 可以使用的对象不同：
   for...in循环可以用于遍历普通对象的属性。但是它不能用于遍历数组等可迭代对象，因为它会遍历数组的所有属性，包括数组的原型属性。
   for...of循环只能用于遍历可迭代对象，例如数组、字符串、Map、Set等。
   综上所述，for...in循环用于遍历对象的属性，而for...of循环用于遍历可迭代对象的值。在使用时需要根据不同的情况选择合适的循环结构。

**中断for**

- continue：终止该次循环，进入下一次，使用所有循环结构

- break：跳出循环，执行循环后的语句，如果多层循环，只会退出当前层循环

- return：终止循环，结束当前方法

## 深浅拷贝 递归

在声明基本类型的变量时，变量的值会存储在栈内存当中，声明引用类型的变量时，会在堆内存中分配一个空间来存储引用类型的值。同时，在栈中也会保存一个引用地址指向这一块空间。声明一个变量B，并且B赋值为已存在的基本类型变量a，那么它赋值的是存储在栈中的真实的值，对于引用类型而言，声明一个变量O2，并给这个O2赋值为已存在的O1，那么他赋值的是栈中的引用地址，当改变O1O2任意一个时，真正改变的是堆内存中存储的值，那么当输出O1或者O2的时候，他们输出的结果都是会发生改变的

**浅拷贝**是新对象的属性和源对象的属性会共用同一个内存空间，浅拷贝拷贝的是地址

实现方法是Object.assgin()，它会将一个或多个源对象的可枚举属性复制到目标对象中，如果目标对象中已有相同的属性，则会覆盖原有的属性值

另一个实现方式是数组的浅拷贝可以使用slice()方法、concat()方法或者...展开运算符实现

**深拷贝**是新对象的属性和源对象的属性会不会共用同一个内存空间，需要在堆内存中开辟一块新的空间来存放这个属性的值  

深拷贝会递归拷贝对象的所有属性，包含子对象

实现方法是JSON.parse(JSON.stringify()) ，用JSON格式实现深拷贝， 将需要拷贝的对象先转为字符串，再将字符串转为新的对象，这种方法可以一次性处理整个对象，缺点是只能处理JSON支持的数据类型，不能处理函数和正则表达式

递归拷贝，遍历需要拷贝的对象，对每个属性判断是否是基本数据类型如果是就直接拷贝，否则就递归调用自身进行深度拷贝

使用lodash库cloneDeep方法 

**浅拷贝方式**：

拷贝对象-Object.assgin()或展开运算符...{obj},

拷贝数组Array.prototype.concat()

**深拷贝方式**：

1. 使用lodash库cloneDeep方法 

2. 使用JSON.parse(JSON.stringify()) 

   **缺点：**

   1. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；
   2. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；
   3. 如果obj有函数、undefined，则序列化之后的结果会把函数、undefined丢失。
   4. 如果obj里有NaN、 Infinity和-infinity，则序列化的结果会变成null
   5. JSON.stringify()只能序列化对象的可枚举的自有属性,例如如果obj中的对象是有构造函数生成则使用JSON.parse(JSON.stringify(obj)深拷贝后,会丢弃对象的constructor;
   6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；

3. 递归

## 闭包

函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包

**闭包的作用：**

实现模块化：通过闭包，可以封装变量和函数，避免污染全局命名空间，实现模块化开发。

实现私有变量和私有方法：通过闭包，可以创建私有变量和私有方法，避免被外部访问。

缓存变量：通过闭包，可以缓存变量，避免重复计算，提高性能

**闭包可能引起的问题？**

使函数内部变量存在于内存中，闭包多的时候，内存消耗大

在IE浏览器中会导致内存泄露，手动将外部变量置为null

> IE浏览器采用的是引用计数垃圾回收机制。在闭包中，由于内部函数引用了外部函数的变量，导致外部函数的作用域对象无法被销毁，引用计数无法降为0，从而导致内存泄露
>
> 在其他浏览器中，如Chrome、Firefox等，采用的是标记清除垃圾回收机制。闭包执行完之后，如果没有其他函数引用外部函数的变量，就会把这个变量标记为不可访问，从而被回收

**闭包的使用场景**

- setTimeout传参
  - 回调
  - 函数防抖

- 封装私有变量 
  - 实现类和继承

**为什么要使用闭包？**

- 使用闭包可以延长局部变量的生命周期，不让局部变量使用后立即释放，被删除。

**闭包怎么实现私有变量和私有方法**

闭包可以通过将变量和函数定义在外部函数内部，然后在内部函数中访问这些变量和函数，从而实现私有变量和私有方法。

具体实现方法如下：

1. 将需要私有的变量和函数定义在外部函数内部。
2. 在外部函数内部定义一个内部函数，该内部函数可以访问外部函数内部的变量和函数。
3. 在内部函数中定义需要暴露给外部的函数，将其作为内部函数的返回值。
4. 外部函数返回内部函数，从而形成闭包，内部函数可以访问外部函数的变量和函数，但是外部函数无法访问内部函数的变量和函数，从而实现私有变量和私有方法。

示例代码如下：

```js
function outer() {
  var privateVar = 10; // 私有变量
  function privateFunc() { // 私有方法
    console.log('This is a private function');
  }
  return {
    publicFunc: function() { // 公有方法
      console.log('This is a public function');
      privateFunc();
      console.log('Private variable:', privateVar);
    }
  }
}

var obj = outer();
obj.publicFunc(); // 输出：This is a public function
                  // This is a private function
                  // Private variable: 10
```

在上述示例中，私有变量和私有方法是通过在外部函数中定义变量和函数，然后在内部函数中访问这些变量和函数，从而实现的。公有方法是通过将需要暴露给外部的函数定义在返回对象中，从而实现的。

## 垃圾回收机制

JavaScript的垃圾回收机制是自动的，它通过监视对象的引用关系来确定哪些对象是活动的，哪些对象可以被回收。当一个对象不再被引用时，它就会被标记为垃圾，等待垃圾回收器将其回收。

JavaScript垃圾回收器的实现通常使用两种算法：标记清除和引用计数。

- 标记清除算法：垃圾回收器会先标记所有可以访问的对象，然后清除所有未被标记的对象。
- 引用计数算法：垃圾回收器会记录每个对象被引用的次数，当引用次数变为0时，就会回收该对象。

在实际应用中，大多数浏览器都采用标记清除算法来进行垃圾回收，因为引用计数算法容易出现循环引用的情况，导致一些对象无法被回收。

## 作用域链

内部函数访问变量，先在自身作用域找声明，如果没有，往外层找，直到找到全局，如果有，采取就近原则

## this指向



## 事件委托&事件冒泡

事件冒泡（Event Bubbling）是指当一个元素上触发某个事件时，该事件会从该元素开始向上冒泡到祖先元素，直到到达文档根节点。在事件冒泡过程中，可以通过事件对象的target属性来获取当前触发事件的元素。

事件冒泡机制的优点是可以在父元素上统一处理多个子元素的事件，从而减少代码量和提高性能。同时，也可以方便地通过事件委托来实现动态绑定和解绑事件处理程序的需求。但是，如果不加以控制，事件冒泡也可能会导致意外的事件触发和处理，从而影响应用程序的稳定性和可靠性。因此，在实际应用中需要谨慎使用事件冒泡和事件委托技术，合理控制事件的传播和处理。

事件委托（Event Delegation）是一种常见的优化技巧，它利用了事件的冒泡机制来减少事件处理程序的数量。事件委托的核心思想是将事件处理程序绑定到父元素上，而不是绑定到每个子元素上。当子元素上触发事件时，事件会冒泡到父元素，由父元素上的事件处理程序来处理。

例如，如果我们需要对一个列表中的每个项绑定点击事件，我们可以绑定一个事件处理程序到列表的父元素上，然后通过事件委托来处理每个子元素的点击事件。这样就可以避免在每个子元素上都绑定一个事件处理程序，从而提高性能和代码的可维护性。

## 执行栈

执行栈是JavaScript中的一种数据结构，用于存储代码执行的顺序。当JavaScript代码被执行时，它会被添加到执行栈中。代码按照先进先出的顺序执行，也就是说，最先添加到执行栈中的代码最先执行，最后添加的代码最后执行。

当JavaScript执行一个函数时，它会将该函数添加到执行栈中，并在函数执行完毕后将其从执行栈中移除。如果函数内部调用了其他函数，那么这些函数也会被添加到执行栈中，直到所有的函数都执行完毕并从执行栈中移除。

## 如何理解JS的异步

**JS是一门单线程的语言**，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面、执行 JS都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步的方式来避免。 具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。

当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行（这里涉及到JS的事件轮询机制，可以展开讲）。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

## 事件循环

事件循环是JavaScript中的一种机制，用于处理异步任务。当JavaScript执行一个异步任务时，它会将该任务添加到事件队列中，而不是执行栈中。当执行栈中的所有任务都执行完毕后，JavaScript会检查事件队列中是否有任务需要执行。如果有，JavaScript会将队列中的第一个任务添加到执行栈中，并执行该任务。

JavaScript事件循环的过程是不断重复的，直到事件队列中没有任务为止。这意味着JavaScript可以同时处理多个异步任务，而不会阻塞其他任务的执行。

## 宏任务&微任务

ECMscript里面是没有宏任务微任务概念的。先宏后微是因为整个的js代码，js变量的声明，js方法的实现，都属于宏任务的范畴当中，有先宏后微这个说法是因为到了事件循环的机制中的时候，会存在事件队列，存在一个调用的栈，还有一个出队列和入栈的过程，在这个过程里面他会把当前现有的宏任务都执行完，然后再执行对应的微任务。等把宏任务下面的所有的微任务都执行完之后，在执行下一个宏任务

JS中的任务分为宏任务和微任务。

宏任务是指由浏览器或者Node.js环境提供的任务，例如DOM事件、setTimeout、setInterval等等。宏任务的执行顺序由浏览器或者Node.js环境决定，每个宏任务执行完后，会清空微任务队列。

微任务是指在当前宏任务执行完后立即执行的任务，例如Promise.then、MutationObserver等等。微任务的执行时机在宏任务执行完后，会在当前宏任务结束之前执行，也就是说在下一个宏任务之前。微任务执行完后，会清空微任务队列，如果在微任务执行期间产生了新的微任务，那么会在当前微任务队列执行完后继续执行新的微任务队列。

总结一下，宏任务和微任务的执行顺序如下：

1. 执行当前宏任务
2. 执行当前宏任务产生的微任务
3. 执行新的宏任务
4. 重复执行2、3步骤，直到所有任务都执行完毕

需要注意的是，由于微任务的执行时机在宏任务执行完后，所以在同一个宏任务中产生的微任务会在当前宏任务结束之前执行完毕，而不会产生新的宏任务。

##  原型链 

JS的每个函数在创建的时候，都会生成一个属性`prototype`，这个属性指向一个对象，这个对象就是此函数的`原型对象`。该`原型对象`中有个属性为`constructor`，指向该函数。

每个通过`构造函数`创建出来的`实例对象`，其本身有个属性`__proto__`，这个属性会指向该`实例对象`的`构造函数`的`原型对象`，这么说好像有点绕

当访问一个`对象`的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的`__proto__`隐式属性，找到它的`构造函数`的`原型对象`，如果还没有找到就会再在其`构造函数`的`prototype`的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为`原型链`。

**原型继承：**

原型继承: 把父级实例化对象给到子级的原型对象

再把constructor重新指向自己的构造函数

**原型链：** 每一个对象都有自己的原型, 而原型也是对象,也会有自己的原型，此次类推形成链式结构。称之为原型链。(原型链的终点是null) 

**对象访问原型链规则：** 就近原则

对象先访问自己的，自己没有就找原型的，原型没有就找原型的原型，一直到原型链终点null.如果还找不到。  属性则获取undefined, 方法则会报错 xxx is not function



## 继承

在 JavaScript 中，实现继承的方式有以下几种：

1. 原型链继承
   原型链继承是通过将子类的原型指向父类的实例来实现继承。这种方式简单易懂，但是会存在引用类型共享和无法向父类传递参数等缺点。

2. 构造函数继承
   构造函数继承是通过在子类的构造函数中通过call借调父类的构造函数来实现继承。这种方式可以避免引用类型共享的问题，但是无法继承父类的原型上的属性和方法。

3. 组合继承
   组合继承是将原型链继承和构造函数继承组合使用，既能继承父类原型上的属性和方法，又能避免引用类型共享的问题，但是会存在重复调用父类构造函数的问题。

4. 原型式继承
   原型式继承是通过复制一个对象来实现继承，这种方式可以实现类似于对象的克隆，但是会存在引用类型共享的问题。

5. 寄生式继承
   寄生式继承是在原型式继承的基础上添加一些扩展方法来实现继承，但是同样会存在引用类型共享的问题。

6. 寄生组合式继承
   寄生组合式继承是在组合继承的基础上进行优化，避免重复调用父类构造函数，可以实现继承父类原型上的属性和方法，并避免引用类型共享的问题。

## 防抖节流

- **防抖**：**任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。**

结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！

空讲无益，show you 场景：

有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。

```js
  // 2、防抖功能函数，接受传参
    function debounce(fn) {
      // 4、创建一个标记用来存放定时器的返回值
      let timeout = null;
      return function() {
        // 5、每次当用户点击/输入的时候，把前一个定时器清除
        clearTimeout(timeout);
        // 6、然后创建一个新的 setTimeout，
        // 这样就能保证点击按钮后的 interval 间隔内
        // 如果用户还点击了的话，就不会执行 fn 函数
        timeout = setTimeout(() => {
          fn.call(this, arguments);
        }, 1000);
      };
    }
```



- **节流**：**指定时间间隔内只会执行一次任务。**

那么，节流在工作中的应用？

1. 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。
2. 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。

```js
 // 2、节流函数体
    function throttle(fn) {
      // 4、通过闭包保存一个标记
      let canRun = true;
      return function() {
        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数
        if(!canRun) {
          return;
        }
        // 6、将 canRun 设置为 false，防止执行之前再被执行
        canRun = false;
        // 7、定时器
        setTimeout( () => {
          fn.call(this, arguments);
          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true
          canRun = true;
        }, 1000);
      };
    }
```



Lodash 的 debounce 和 throttle 的实现

## 前端如何捕获错误

可以直接用try catch捕获正常代码中的一些错误。但是这只适用于那种同步代码，对于Promise这种类型来说，我们是没有办法try catch直接捕获的。我们对于Promise的异常可以直接在Promise的catch里面去捕获错误，另外，我们可以把Promise放到async和await的函数里面，把它变成类似于同步函数的一个形式，那我们就可以在里面直接使用try catch进行错误捕获。

## 数组转树形结构

方法一：递归函数

```js
function transArrToTree(list,pid) {
  const arr = []
  list.forEach(item => {
    if(item.pid === pid) {
      item.children = transArrToTree(list,item.id)
      arr.push(item)
    }
  })
  return arr
}
```

方法二：map映射

```js
export function transListToTreeUseMap(list) {
  const arr = []
  const map = {}
  list.forEach(item => {
    item.children = []
    map[item.id] = item
  })
  list.forEach(item => {
    if (map[item.pid]) {
      map[item.pid].children.push(item)
    } else {
      arr.push(item)
    }
  })
  return arr
}
```

1. 首先定义一个空数组 `arr` 和一个空对象 `map`。
2. 遍历传入的列表 `list`，为每个节点添加一个空的 `children` 数组，并将节点对象以 `id` 为键，以节点对象本身为值，存入 `map` 对象中。
3. 再次遍历传入的列表 `list`，对于每个节点，如果其父节点在 `map` 对象中存在，则将该节点添加到其父节点的 `children` 数组中；否则，将该节点添加到 `arr` 数组中。
4. 最后返回 `arr` 数组，即为转换后的树形结构数据。

这段代码的主要思路是利用一个对象 `map` 来存储每个节点对象，以便在后续遍历中快速查找其父节点，并将其添加到父节点的 `children` 数组中。

## 树形扁平化转数组

递归函数

这段代码实现了将一个嵌套的树形结构数据扁平化的功能。具体实现如下：

1. 定义一个空数组 `arr`。
2. 遍历传入的树形结构数据 `data`，对于每个节点，判断其是否有子节点，如果有，则递归调用 `dataFattening` 函数，将子节点扁平化后合并到 `arr` 数组中；否则，将该节点直接添加到 `arr` 数组中。
3. 最后返回 `arr` 数组，即为扁平化后的数据。

这段代码的主要思路是利用递归函数将嵌套的树形结构数据转换成扁平化的数组。在递归过程中，对于每个节点，如果它有子节点，则递归调用函数处理子节点，并将子节点扁平化后的结果合并到当前节点的扁平化结果中。如果当前节点没有子节点，则直接将当前节点添加到扁平化结果中。

需要注意的是，在这段代码中使用了可选链操作符 `?.`，它用于判断一个对象是否有某个属性或方法，如果有则返回该属性或方法的值，否则返回 `undefined`。这样可以避免在访问不存在的属性或方法时出现报错，提高代码的健壮性。

```js
function dataFattening (data) {
  const arr = []
  this.data.forEach(item => {
    if(item.children?.length) {
      arr = [ ...arr, ...dataFattening(item.children) ]
    }esle {
      arr.push(item)
    }
  })
  return arr
}
```

## 无感知登录

b站小鹿仙
